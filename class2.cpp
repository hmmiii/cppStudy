#include <iostream>
#include "Counter.h"

using namespace std;

/*
* 객체(object)
클래스의 실제 사례(instance)에 해당되며, 고유한 속성값(데이터 멤버의 값)을 가지며, 이를 바탕으로 클래스에 정의된 행위를 할 수 있다.

정해진 처리를 할 수 있고 -> 행위, 메소드, 멤버함수
처리 과정에 따라 내부 상태가 변화할 수 있고 -> 속성, 데이터멤버
다른 객체와 상호작용이 가능 -> 메시지 전달(멤버함수 호출)
예) 시계

* 클래스(class)
프로그램이 표현하고자 하는 대상(객체)이 어떠한 속성(데이터 멤버)을 저장하고 있어야 하고, 어떤 행위(멤버함수)을 할 수 있는가를 선언한 것

객체의 설계도
객체를 생성하는 것을 사례(instance)를 생성한다 라고 한다.
예) 시계의 설계도

클래스의 선언부

class className{
    가시성 지시어1:
        데이터 멤버 선언;
        멤버함수 선언; // 원형 선언 또는 멤버함수 정의
    가시성 지시어2:
        데이터 멤버 선언;
        멤버함수 선언; // 원형 선언 또는 멤버함수 정의
        ....
}

클래스를 사용할 경우 대부분 헤더파일을 만들어서 사용한다.

* 클래스의 가시성 지시어
private(default), public, protected가 있다.
- private
    공개범위가 아래로 제한.
        소속 클래스의 멤버 함수
        친구 클래스의 멤버 함수 및 친구 함수
        그외 범위는 비공개
    용도
        정보 은닉
        클래스 구현을 위한 내부 상태(데이터 멤버)는 일반적으로 private로 지정
- public
    전 범위가 공개 범위.
    용도
        주로 외부에 제공할 인터페이스를 공개하기 위해 사용
- protected
    상속에 관련.

* 캡슐화(encapsulation)
객체 내부의 상세한 구현 부분과 사용자의 관점을 분리하는 것을 나타낸다. 사용자는 객체의 내부 요소를 직접 사용할 수 없으며, 공개된 인터페이스를 통해 객체를 사용한다.
내부 속성 등 구현에 대한 부분은 공개하지 않고(정보 은닉), 객체 외부에서는 공개된 인터페이스로만 객체를 사용할 수 있음.ㅍ 
예시 : 리모콘을 만드는 방법을 몰라도, 리모콘을 사용할 수 있다. 

* 생성자(constructor)
객체가 생성될 때 수행할 작업을 정의하는 특수한 멤버함수로, 객체의 초기화 작업을 수행한다.
생성자를 다중정의 할 수 있음.
클래스의 이름을 사용해서 선언
생성자 앞에 반환 자료형을 표시하지 않으며 값을 return 하지 않음
생성자는 public 으로 선언해야 함. 그래야 외부에서 클래스 객체 생성 가능

class className{
    .....

    public:
        className(fParameterList){
            ..... // 객체 생성을 위한 준비 작업
        }
}

Counter() : value{0} {}; // 생성자 함수, 초기화 리스트 

* 소멸자(destructor)
객체가 소멸될 때 수행할 작업을 정의하는 특수한 멤버함수로, 객체가 가지고 있는 자원을 반납하는 등의 처리를 담당한다.
클래스의 이름에 '~'을 붙여 사용
매개변수가 없으며 클래스에 하나의 소멸자만 사용 가능, 매개변수가 없으므로 다중정의도 불가능.
public으로 선언하는 것이 일반적
상속을 통해 파생 클래스를 정의하는 경우 virtual을 지정해서 가상함수가 되도록 하는 것이 좋음

class className{
    .....

    public:
        className(fParameterList){
            ..... // 객체 생성을 위한 준비 작업
        }

        ~className(){
            ..... // 객체 제거를 위한 정리 작업
        }
}


*/

int main()
{
    // 클래스의 사용
    Counter cnt;
    cnt.count();
    cnt.count();
    cnt.count();
    cout << "계수기의 현재 값 : " << cnt.getValue() << endl;

    return 0;
}
